"""Execution sandbox for running user-provided Python snippets safely."""

from __future__ import annotations

import shutil
import subprocess
import sys
import tempfile
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Optional
from uuid import uuid4


@dataclass(frozen=True)
class SandboxResult:
    """Outcome of executing Python code inside the sandbox."""

    stdout: str
    stderr: str
    artifacts: List[str]


class SandboxRunner:
    """Lightweight sandbox that executes Python code in a temporary directory."""

    def __init__(self, *, python_executable: str | None = None, artifact_root: Path | None = None) -> None:
        self._python = python_executable or sys.executable
        self._artifact_root = Path(artifact_root or Path("artifacts") / "tool_runs").resolve()
        self._artifact_root.mkdir(parents=True, exist_ok=True)

    def run(self, code: str, *, timeout_s: int = 10) -> SandboxResult:
        """Execute the provided Python code with a wall-clock timeout."""

        if not code.strip():
            raise ValueError("Cannot execute empty code payload.")

        with tempfile.TemporaryDirectory() as tmp_dir:
            tmp_path = Path(tmp_dir)
            script_path = tmp_path / "main.py"
            script_path.write_text(code, encoding="utf-8")

            run_id = uuid4().hex
            artifact_dir = self._artifact_root / run_id
            artifact_dir.mkdir(parents=True, exist_ok=True)

            try:
                completed = subprocess.run(
                    [self._python, str(script_path)],
                    cwd=tmp_path,
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=timeout_s,
                )
            except subprocess.TimeoutExpired as exc:
                return SandboxResult(stdout=exc.stdout or "", stderr=_format_timeout_error(exc), artifacts=[])

            artifacts = self._harvest_artifacts(tmp_path, artifact_dir)
            return SandboxResult(stdout=completed.stdout, stderr=completed.stderr, artifacts=artifacts)

    @staticmethod
    def _harvest_artifacts(source_dir: Path, destination_dir: Path) -> List[str]:
        """Copy any generated files (excluding the script) to the artifact directory."""

        artifact_paths: List[str] = []
        for path in _iter_artifact_candidates(source_dir):
            relative_name = path.name
            destination = destination_dir / relative_name
            if path.is_dir():
                shutil.copytree(path, destination, dirs_exist_ok=True)
            else:
                shutil.copy2(path, destination)
            artifact_paths.append(f"artifact://{destination_dir.name}/{relative_name}")
        return artifact_paths


def _iter_artifact_candidates(source_dir: Path) -> Iterable[Path]:
    """Yield files generated by the sandboxed script."""

    for child in source_dir.iterdir():
        if child.name == "main.py":
            continue
        if child.name.startswith("__pycache__"):
            continue
        yield child


def _format_timeout_error(exc: subprocess.TimeoutExpired) -> str:
    """Produce a structured error message for timeout scenarios."""

    return (
        f"Execution timed out after {exc.timeout}s. Partial stdout:\n{exc.stdout or ''}\n"
        f"Partial stderr:\n{exc.stderr or ''}"
    )


__all__ = ["SandboxRunner", "SandboxResult"]

